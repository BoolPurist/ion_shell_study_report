\chapter{Conclutions after the development}

\section{What is left to do}

This section describes which goals for the it project could not be archived.
The description also contains the reasons why a goal could be accomplished.

\subsection{Enriching error messages}

One area of contribution was focused on enriching error message in Ion Shell.
Error messages in Ion Shell already provide specific information about what problem occured.
However the details within certain error messages had some potential for improvement.
The following merged pull requests of mine were focused on that areas:

\begin{itemize}
	\item Out of bounds errors show the invalid index and the length of an array \cite{pr_error_message_shows_invalid_range}.
	\item Errors because of the reference of an undeclared variable now show the name of the undeclared one \cite{pr_better_not_found_variable_show}.
\end{itemize}

Another aspect of missing information for error messages was the source location where an error was encountered.
The source location is the respective line and column number.
The source location in an error message as a feature were noted down in an still opened issue \cite{issue_enrich_error_message_information}.
The parser of ion shell does not keep track of line and columns numbers for statements.
Because of this, one can not simply incorporate the source location into the error messages.

A workaround was attempted via counting at least the line numbers per executed statement.
There is a for loop, see code snippet \ref{code:execution_for_code_snippet} at line \ref{code:execute_loop},
which terminates, parses and executes statements one by one.
This workaround could at least provide the line number of the source location.
That attempt however did not work for all scenarios.
In cases of calling a function in Ion Shell wrong line numbers occur however.
This oddity comes from the fact that statements within a function are executed in a batch.
Let us consider the following code snippet TODO add code snippet.
If an error occurs at line .. then the line number is 4 with the workaround because that is where the function was called.
In addition to that the execution of builin methods do propagate their error up to the execution loop \ref{code:execution_for_code_snippet}.
If an error happens a message is directly printed to the console via this section TODO.

In my view the solution is to rewrite the tokenisation and parsing in a way so that
a token/language items are linked to its respective column and line number.
This rewrite however requires coordination with the respository owners and significant amount of work
which exceeds the available time I could afford to spend for the it project.

\rustCode{execution_loop}{code:execution_for_code_snippet}{file_ref_execute_loop}{For loop which terminates,parses and interprets statements}

