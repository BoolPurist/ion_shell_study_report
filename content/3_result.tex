\chapter{Conclutions after the development}

\section{What is left to do}

This section describes which goals for the it project could not be archived.
The description also contains the reasons why a goal could be accomplished.

One goal was to enrich error message in Ion Shell in a way
so that they also show the location where the error occurred with a respective line and column number.
This improvement upon error message were noted down in an still opened issue \cite{issue_enrich_error_message_information}
The parser of ion shell does not keep track of line and columns numbers for statements.
Because of this one can not incorporate the source location into the error values for later error reporting.
A workaround was attempted via counting at least the line numbers per executed statement.

There is a for loop, see code snippet \ref{code:execution_for_code_snippet} at line \ref{code:execute_loop},
which terminates, parses and executes statements one by one.
This workaround could at least provide the line number of the source location.



\clearpage
\begin{lstlisting}[escapeinside={(*}{*)},label={code:execution_for_code_snippet},language=Rust,caption={For loop which terminates,parses and interprets statements. Source: \cite{file_ref_execute_loop}},captionpos=b]
/// Receives a command and attempts to execute the contents.
pub fn on_command(
    &mut self,
    command_to_execute: impl Iterator<Item = u8>,
    set_cmd_duration: bool,
) -> std::result::Result<(), IonError> {
    let command_start_time = if set_cmd_duration 
    { Some(SystemTime::now()) } else { None };

    for stmt in command_to_execute.batching(
    |cmd| Terminator::new(cmd).terminate()) { (*\label{code:execute_loop}*) 
        // Go through all of the statements and build up 
        // the block stack
        // When block is done return statement for execution.
        for statement in StatementSplitter::new(&stmt) { 
            let statement = parse_and_validate(statement?)?;
            if let Some(stm) = Self::insert_statement(
              &mut self.flow_control, statement
              )? {
                self.execute_statement(&stm)?; 
            }
        }
    }

    if let Some(start_time) = command_start_time {
        if let Ok(elapsed_time) = start_time.elapsed() {
            self.variables_mut()
            .set(
                "CMD_DURATION", 
                elapsed_time.as_secs().to_string()
            );
        }
    }

    Ok(())
}
\end{lstlisting}



