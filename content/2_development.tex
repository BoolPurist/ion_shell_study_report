\chapter{Development in Ion Shell}

\section{Finding areas for contribution}

With the goal to contribute to Ion shell during the period of the it project, the possible bug fixes/features needed to be determined first.
The following activities were undertaken to find out concrete tasks to find out development goals:

\begin{itemize}
	\item Going through the online manual of Ion Shell.
	\item Reading posted issues on the GitLab Repository of Ion shell.
	\item Explore scripting of Ion Shell.
\end{itemize}

The online manual of the shell is meant for the users of the application.
It focuses on the following points:

\begin{itemize}
	\item What and how something can be done in an interactive session.
	\item Features of the scripting language.
	\item Philosophy the application. Why does it exits and what it is supposed to be.
\end{itemize}

Ion manual is build by the program of the rust progrom mdBook, \cite{mdBook}, which converts markdown file into folder of
HTML, CSS and JavaScript files for hosting a documentation as a website.
Investigating the online manual of Ion shell provided the overview of already implemented features and how the shell was meant to be used.
While reading the manual, it became clear that the documentation lacked explanations in certain areas.
Later on additions to the documentation were also required for new implemented features in Ion Shell.
Because of this the manual presents one of the fields in Ion shell for contribution.
Another important source for the deduction of tasks was the collection of issues and pending pull requests from a repository.

\section{Used programming languages}

The whole program is developed in the Rust programming language like the whole ecosystem of Redox os.
Beside the Rust, knoweldge about Make files proved invaluable to understand the working of the integration tests and
allowed to add more capability of running only one specific interrogation test, accomplished by the pull request \cite{pr_single_test_selectable}.
The mastering of the scripting language of Ion Shell was vital too. Without it I could have not found out the correct behaviour
which is to be archieved after a bug fix or feature implemantation.

\section{Verification of bug fixes and implementation via automated testing of features}\label{impl:integration_test}

The main way to verify the working of features and bug fixes is the usage of unit tests and integration tests.
Unit tests and integration tests are the 2 forms of tests used to verify the functionality of the shell.
The observation of the code base suggests that the first form as unit tests are mainly used to inspect the correctness of tokenisation, parsing and
evaluation of the builtin functions of the shell in isolation.
It is important to note that these unit tests execute and assert inner/private functions too
in contrast to other programming languages like CSharp where unit test should not access private functionality easily.
This is typical in the Rust language because unit tests are often in the children module in respect of the code to be tested.
Visibility in Rust enables code in a children module to have full access to all functionality in a parent module.
This allows to test private functions in Rust easily \cite{rust_testing_private_function}.

Integration tests depend on the kind of application.
Ion shell's approach to integration test is the execution of script files
and comparing the output to text files which contain the expected output for the test.
This kind of integration test therefore focuses on the scripting aspect of the shell.
Especially this kind of testing is valued highly according to the Contributing Guidelines of this project \cite{ion_shell_contributing}.
Since rust does not provide a builtin way to perform these kinds of tests,
a rather complex bash script was written to orchestrate this kind of integration tests.
Before this it project there was no explanation of how these new integration tests are executed and how they should be written.
It was however paramount to add new integration tests to verify bug fixes and implemented features.
A documentation section in the contributing guideline was crafted during the process of
learning the working of this integration tests \cite{ion_shell_contributing}.
This will hopefully reduce the learning effort for future contributors in the area of integration tests.

\section{Example of development}

\subsection{Implementing an array method in Ion Shell}

The implementation of the feature of the method "subst" ought to represent in the development work in Ion Shell.
This method allows to provide a default value for an empty array.
The following tasks were performed to archive the implementation:

\begin{itemize}
	\item Determine the desired behaviour of the array method.
	\item Create a test to verify the functionality of the implementation.
	\item Implement the method in Ion shell.
	\item Document this feature in the online manual of Ion shell.
\end{itemize}

In the end the implementation was proposed and merged under the following pull request \cite{pr_subst_method}.

\subsubsection{Finding out the desired behaviour of "subst"}\label{subst_desired_behaviour}

This feature was requested in an issue a certain while ago \cite{ion_shell_subst_issue}.
In this issue the specifics of behaviour of this array method have already been discussed too.
The discussion concluded the following signature of "subst".

```text
subst(input: T, default: T) -> T
```
source: \cite{issue_subst_request}

Where the invariant says that T must be of type array.
This array method takes two arguments as arrays and returns either the first or second argument.
The first one is returned if it is not an empty array. Otherwise the second argument is returned.
The accomplished implementation follows the signature and invariant.

\subsection{Creating integration test for the implementation}\label{subst_test}

To verify the functionality of the implementation, an integration test was added to test suit.
An integration test consists of 2 files. One is an ion file which is executed by the shell an other is a plain text file with extension "out".
This text file describes the expected output of the execution of the ion test file.
For this implementation there is the file "subst.ion" and "subst.out"
where "subst" is the name of the test. Both file must share the same base file name, here "subst".

The code snippet \ref{code:subst_test} represents the test code and should
produce the following expected output \ref{code:subst_test_out}.

In additions to the integration tests unit tests were put in place to verify the finer details of the implementation.
Every unit test is presented as function annotated with "\#[test]" in the code snippet \ref{code:unit_test_subst}.

\ionCode{subst_test}{code:subst_test}{ion_shell_subst_ion_test}{Ion shell script for testing implementation of subst method}
\ionCode{subst_out}{code:subst_test_out}{ion_shell_subst_ion_test_out}{Expected output of executed test script for subst \ref{code:subst_test}.}

\rustCode{unit_test_subst}{code:unit_test_subst}{pr_subst_method}{Unit test for the implementation of the method "subst".}

\subsection{Implementation of "subst"}

After settling goals and the verification of the implementation it is time make this feature a reality via Rust code.
The implementation of the method is contained the function shown in \ref{code:array_method_impl}.
The first part of the function validates if the first and second argument are of type array,
from line \ref{code:subst_start_validate} to line \ref{code:subst_end_validate}.
This validation ensures that an error is returned if the user violates the conditions which were lay out, see \ref{subst_desired_behaviour} section.
Errors in Rust are propagated by value rather than exceptions. This is done via the generic enum type Result<T, E> where T is the type of the value in the successful case
and E is the type of value which communicates what went wrong in case of error.
A functions therefore declares via its return type of the enum Result<T, E> that it can fail, line \ref{code:subst_return_type}.
Within the code section for validating the arguments, the function returns Err variants, case of the violation of the stated conditions
\ref{subst_desired_behaviour}, at several places, at line \ref{code:subst_err_1}, \ref{code:subst_err_2} and \ref{code:subst_err_3}.
There is another spot where an error is returned. This spot can be found by the "?" character which signifies that if an error is given,
then propagate this error to the caller of the function at line \ref{code:subst_end_validate}.
This propagation equals a rethrowing of an exception in C\#:

\begin{verbatim}
	try {
		var array = expand_func.slice_array(elements, this.selection);
	} catch(Exception e) {
		throw e;
	}
\end{verbatim}

Between line \ref{code:subst_success_start} and line \ref{code:subst_success_end} the success case is performed by returning the first argument back if it is not empty, line \ref{code:subst_return_success_1}.
The second one is returned only if the first one is an empty array, line \ref{code:subst_return_success_2}.

\rustCode{array_method_impl}{code:array_method_impl}{pr_subst_method}{Function which implements the subst method}

\subsection{Documentation of "subst"}

After the implementation an explanation of this method was noted down in array method section of the Ion Shell manual \cite{ion_manual_array_methods}.
This documentation covers the following aspects:
\begin{enumerate}
	\item What does it do.
	\item What is expected of the provided arguments and when an error is raised.
	\item Example of the usage with an expected output.
\end{enumerate}

The first and second point are communicating the established conditions the functions expects to be called, shown at \ref{subst_desired_behaviour}.


